# internet-checksum

## 题目描述

你需要在 `checksum.cpp` 中实现下面的函数 `validateAndFillChecksum`，这个函数接收一个 IPv6 的 packet，在 IPv6 Header 之后一定是一个 UDP 或者 ICMPv6 的 packet。该函数的返回值为 UDP 或者 ICMPv6 中的校验和是否正确；同时，无论原来的校验和是否正确，该函数返回时，packet 中的校验和应该被填充为正确的值。

```cpp
// 函数注释见代码
bool validateAndFillChecksum(uint8_t *packet, size_t len) {
  return true;
}
```

在 IPv6 中，Header 不再有校验和（checksum）字段，而在 UDP 和 ICMPv6 协议中计算校验和的时候，需要将 IPv6 Header 的一部分数据考虑进来，这就是 Pseudo Header。其由下面若干部分组成：

1. 16 字节的 Source IPv6 Address
2. 16 字节的 Destination IPv6 Address
3. 4 字节的 UDP/ICMPv6 Length（别忘了要用网络字节序）
4. 3 字节的 0，然后是 1 字节的 Next Protocol（对 UDP 来说是 17，对 ICMPv6 来说是 58）

如果你对这部分仍有疑惑，可以对照 [UDP Checksum](https://en.wikipedia.org/wiki/User_Datagram_Protocol#IPv6_pseudo_header)  和 [ICMPv6 Checksum](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol_for_IPv6#Checksum) 网页上的表格进行实现。

校验和的检验方式如下：

1. 在 IPv6 Pseudo Header 后拼接上 UDP/ICMPv6 packet，拼接后的数据每 16 个二进制位为一组，视作一个大端序的整数。将所有 16 位的整数相加；
2. 如果上述求和结果发生溢出（二进制表示下超过 16 位），则将其截断为低 16 位及溢出部分，然后将溢出部分加到低 16 位（例如：求和结果为 0x1CB2F，则拆成低 16 位的 0xCB2F 与溢出部分 0x1，并相加 0xCB2F + 0x1）；
3. 如果结果又发生了溢出，则重复上述操作，直到不发生溢出；
4. 上述结果若等于 0xFFFF，则表示校验和正确，反之错误。

特别地，在 UDP 中，校验和字段为 0 表示没有进行校验和的计算。然而，由于 IPv6 头部中没有校验和字段等原因，承载于 IPv6 的 UDP 要求必须进行校验和计算。因此，对于 UDP 而言，若接收方在检查时发现校验和字段为 0，则应该认为其是错误的。

由于一个字节占 8 个二进制位，因此校验和检验的步骤 1 中“每 16 个二进制位为一组”可能面临数据不足的情况，比如 UDP/ICMPv6 packet 的长度为奇数个字节（IPv6 Pseudo Header 的长度固定为 40 字节）。将第 1 步的拼接结果后补零至偶数个字节是一种可行的处理方法，下面的校验和计算中也是类似的。

校验和的计算方式如下：

1. 将校验和字段更改为 0；
2. 执行校验和检验中的步骤 1、2、3，得到 16 位的结果；
3. 将得到的 16 位结果按位取反，使用大端序填充到校验和字段，即完成了校验和的计算。

与校验和检验中 UDP 的特殊处理一样，由于 UDP 中校验和为 0 有特殊的意义，如果发送方计算出的校验和确实为 0x0000，则也需要将其设置为 0xFFFF，以示区别。对于其他情况（当然这里只有 ICMPv6），当接受到校验和应该为 0x0000 但实际为 0xFFFF 的情况时，函数返回值设为 true（表示校验成功），并将 packet 中的校验和设为 0x0000（改成正确的）。

请同学们分析上述两种特殊处理做法的正确性：上述做法是否会混淆校验和为 0x0000 与 0xFFFF 两种情况？对 UDP 校验和的更改能通过校验和的检验吗？又为何要对“应该为 0x0000 但实际为 0xFFFF”的情况特殊处理呢？如果你对这部分有疑惑，可以参考下面“注意事项与说明”中第 2 条的分析。


注意事项及说明：

1. 上述对于 checksum 的说明中，我们先给出了校验和的检验方法，而后给出了校验和的计算方法，这种叙述方式是有意为之的。请注意校验和计算方式中的第 1 步，其并非简单地给出了校验和的计算初始值，而是一步需要实际完成的操作：将 UDP/ICMPv6 校验和字段改为 0。完成这一步后，校验和的检验就不能进行了。因此我们建议同学们可以按照上面的过程，逐步进行编写，即使这样的流程可能略显别扭。

2. 对于校验和计算中特殊处理方式正确性的进一步讨论：校验和计算与检验方法中有这样一个性质，即按照计算的算法得到的校验和，检验得到的一定是正确的结果，但反之不然。我们可以观察到这么一个事情，即校验和计算方式得到的结果不可能是 0xFFFF：因为在计算的第 2 步过程中，求和的结果不可能是 0x0000，因此在第 3 步取反以后，最终的校验和不可能是 0xFFFF。但如果校验和等于 0xFFFF，按照检验校验和正确的算法，得到的结果依然是正确的。你可以想一想，为什么在这种运算方式下，将 0x0000 替换为 0xFFFF，或者反过来把 0xFFFF 替换为 0x0000 都不影响求和的计算结果，这解释了为什么 UDP 中将结果为 0x0000 的校验和更改为 0xFFFF 是正确的。

   同学你可能会问，如果大家都用上面的计算方法得到校验和，为何还会出现 0xFFFF 的情况呢？“应该为 0x0000 但实际为 0xFFFF”的情况存在吗？在 [RFC 1141](https://datatracker.ietf.org/doc/html/rfc1141) 中定义的增量更新的算法因为设计上的纰漏，会导致计算出 0xFFFF 的校验和，在之后的 [RFC 1624](https://datatracker.ietf.org/doc/html/rfc1624) 中才得以修复。但很可惜的是，一些系统已经实现了错误的算法。因此目前的网络栈对这个问题的策略是：校验的时候，认为 0xFFFF 是正确的校验和；计算的时候，不会计算出 0xFFFF，因此也就有了上面的特殊处理：当接受到校验和应该为 0x0000 但实际为 0xFFFF 的情况时，函数返回值设为 true，并将 packet 中的校验和设为 0x0000。对于 UDP 而言，由于其校验和为 0 有特殊含义，仍需要按照前文规定的方法将结果为 0x0000 的校验和更改为 0xFFFF 以示区别。

3. 作为补充知识，当 UDP 作为 IPv4 的 Payload 时，校验和字段为 0 表示发送方没有进行校验和的计算，此时接收方忽略校验和检查，直接认为校验和是正确的；当校验和字段不为 0 时，接收方同样需要按照上述检验算法进行验证。

4. 以上的校验和计算方式和检验方式定义在 [RFC 1071](https://datatracker.ietf.org/doc/html/rfc1071) 中。

5. 你可以用一些结构体来简化解析过程：`struct ip6_hdr`、`struct udphdr` 和 `struct icmp6_hdr`，代码中已经提供了一些使用的例子。对于 UDP/ICMPv6 Length，你可以用 `htonl/htons/ntohl/ntohs` 函数来转换字节序。

6. 你不需要处理输入输出，你只需要在本地执行 `make grade` 就可以进行本地评测。在本题中，保证 packet 中的数据只有 checksum 可能是不合法的。

# 输入输出格式

输入文件是 PCAP 格式，里面含有 n 个 IPv6 packet，main 函数会使用 HAL 读取输入文件中的数据，并通过参数传递给你实现的函数。你可以用 Wireshark 去打开它。

输出文件有 2n 行，第 2\*i-1 行一个字符串 Yes/No 表示第 i 个 IPv6 packet 的校验和验证是否正确；第 2\*i 行一个十六进制字符串表示第 i 个 IPv6 packet 进行校验和计算后的数据。
